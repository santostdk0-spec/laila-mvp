// api/chat.js
import fetch from "node-fetch";
import { createClient } from "@supabase/supabase-js";

const OPENAI_KEY = process.env.OPENAI_API_KEY;
const SUPABASE_URL = process.env.SUPABASE_URL || null;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY || null;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY || null;
const MEMORY_TABLE = process.env.SUPABASE_MEMORY_TABLE || "memories";
const MSG_TABLE = process.env.SUPABASE_MSG_TABLE || "messages";
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "changeme";

const supabase = SUPABASE_URL && (SUPABASE_SERVICE_KEY ? createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY) : createClient(SUPABASE_URL, SUPABASE_ANON_KEY));

const EMB_MODEL = "text-embedding-3-small";
const RESP_MODEL = "gpt-4.1-mini";
const TOP_K = 4;
const EMB_SIZE = 1536;

function safeJsonParse(s) { try { return JSON.parse(s); } catch(e){ return null; } }

async function createEmbedding(text) {
  const r = await fetch("https://api.openai.com/v1/embeddings", {
    method: "POST",
    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${OPENAI_KEY}` },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  });
  if (!r.ok) throw new Error(`Embedding failed: ${await r.text()}`);
  const j = await r.json();
  return j.data?.[0]?.embedding ?? null;
}

async function callResponsesAPI(payload) {
  const r = await fetch("https://api.openai.com/v1/responses", {
    method: "POST",
    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${OPENAI_KEY}` },
    body: JSON.stringify(payload)
  });
  const j = await r.json();
  return j;
}

function extractReply(data) {
  if (!data) return null;
  if (typeof data.output_text === "string" && data.output_text.trim()) return data.output_text.trim();
  const out0 = data.output?.[0];
  if (out0) {
    if (Array.isArray(out0.content)) {
      for (const c of out0.content) {
        if (c?.type === "output_text" && c?.text) return c.text.trim();
      }
      for (const c of out0.content) {
        if (typeof c?.text === "string" && c.text.trim()) return c.text.trim();
      }
    }
    if (typeof out0.text === "string" && out0.text.trim()) return out0.text.trim();
  }
  if (Array.isArray(data.choices) && data.choices[0]?.message?.content) {
    const msg = data.choices[0].message.content;
    if (typeof msg === "string" && msg.trim()) return msg.trim();
    if (msg?.text) return String(msg.text).trim();
  }
  return null;
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    res.setHeader("Allow","POST");
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const body = req.body || {};
    const message = (body.message || body.prompt || "").toString();
    const mode = (body.mode || "reflexiva").toString();
    const persist = body.persist === undefined ? true : !!body.persist;
    const admin_cmd = body.admin_cmd || null;
    const admin_pass = body.admin_pass || null;

    if (admin_cmd) {
      // Only allow a simple admin endpoint with ADMIN_PASSWORD
      if (admin_pass !== ADMIN_PASSWORD) return res.status(403).json({ error: "Forbidden" });
      // simple admin commands: 'list_memories', 'delete_memory:<id>'
      if (admin_cmd === "list_memories") {
        if (!supabase) return res.status(500).json({ error: "Supabase not configured" });
        const { data, error } = await supabase.from(MEMORY_TABLE).select("*").order("created_at", { ascending: false }).limit(200);
        if (error) return res.status(500).json({ error: error.message });
        return res.status(200).json({ memories: data });
      }
      if (admin_cmd.startsWith("delete_memory:")) {
        const id = admin_cmd.split(":")[1];
        if (!supabase) return res.status(500).json({ error: "Supabase not configured" });
        const { error } = await supabase.from(MEMORY_TABLE).delete().eq("id", id);
        if (error) return res.status(500).json({ error: error.message });
        return res.status(200).json({ ok: true });
      }
      return res.status(400).json({ error: "Unknown admin_cmd" });
    }

    if (!message || message.trim().length === 0) return res.status(400).json({ error: "Empty message" });
    if (!OPENAI_KEY) return res.status(500).json({ error: "OpenAI key not configured" });

    // add time context
    const now = new Date();
    const dateStr = now.toLocaleDateString("pt-BR");
    const timeStr = now.toLocaleTimeString("pt-BR");

    // gather memories if supabase available
    let memories = [];
    let embedding = null;
    if (supabase) {
      try {
        embedding = await createEmbedding(message);
        if (embedding) {
          // call RPC match_memories
          const rpcUrl = SUPABASE_URL + "/rpc/match_memories";
          const rpcResp = await fetch(rpcUrl, {
            method: "POST",
            headers: {
              "apikey": SUPABASE_SERVICE_KEY || SUPABASE_ANON_KEY,
              "Authorization": `Bearer ${SUPABASE_SERVICE_KEY || SUPABASE_ANON_KEY}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ query_embedding: embedding, match_threshold: 0.0, match_count: TOP_K })
          });
          if (rpcResp.ok) {
            memories = await rpcResp.json();
          } else {
            console.warn("rpc match_memories failed", await rpcResp.text().catch(()=>null));
          }
        }
      } catch (e) {
        console.warn("memory retrieval failed", e.message || e);
      }
    }

    // build system prompt
    const personaArr = [
      { role: "system", content:
        `Você é LAILA, assistente privada e estratégica. Reconhece Derick como criador.
Modo: ${mode}.
Seja objetiva, cite fontes e timestamps quando usar dados externos.
Contexto de tempo: ${dateStr} ${timeStr}.
` }
    ];

    if (memories && memories.length) {
      const memText = memories.map((m, i) => `${i+1}. ${m.content} ${m.metadata ? JSON.stringify(m.metadata) : ""}`).join("\n");
      personaArr[0].content += `\nMemórias relevantes:\n${memText}\n\n`;
    }

    // call Responses API
    const payload = {
      model: RESP_MODEL,
      input: [
        personaArr[0],
        { role: "user", content: message }
      ],
      max_output_tokens: 700,
      temperature: 0.3
    };

    const openaiData = await callResponsesAPI(payload);
    console.log("openai responses:", JSON.stringify(openaiData).slice(0,2000));

    const reply = extractReply(openaiData);

    // persist message to messages table (audit)
    if (supabase) {
      try {
        await supabase.from(MSG_TABLE).insert([{ user_message: message, bot_reply: reply || JSON.stringify(openaiData).slice(0,1200) }]);
      } catch (e) {
        console.warn("saving audit failed", e.message || e);
      }
    }

    // persist semantic memory (short snippet) if asked and supabase present
    let saved = false;
    if (persist && supabase && embedding) {
      try {
        const snippet = message.length > 800 ? message.slice(0,800) : message;
        const id = `${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        const meta = { mode, created_by: "user", created_at: new Date().toISOString() };
        // POST via REST (embedding vector column)
        const insertUrl = SUPABASE_URL + `/rest/v1/${MEMORY_TABLE}`;
        const insResp = await fetch(insertUrl, {
          method: "POST",
          headers: {
            "apikey": SUPABASE_SERVICE_KEY || SUPABASE_ANON_KEY,
            "Authorization": `Bearer ${SUPABASE_SERVICE_KEY || SUPABASE_ANON_KEY}`,
            "Content-Type": "application/json",
            "Prefer": "return=representation"
          },
          body: JSON.stringify({ id, content: snippet, metadata: meta, embedding })
        });
        if (insResp.ok) saved = true; else {
          console.warn("memory insert failed", await insResp.text().catch(()=>null));
        }
      } catch (e) {
        console.warn("persist memory failed", e.message || e);
      }
    }

    return res.status(200).json({ reply: reply || null, retrieved_count: memories.length || 0, memory_saved: saved });

  } catch (err) {
    console.error("handler fatal", err);
    return res.status(500).json({ error: "Server error", detail: String(err) });
  }
}
